{"version":3,"sources":["../source/AsYouType.js"],"names":["Metadata","PhoneNumber","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","matchesEntirely","extractCountryCallingCode","extractFormattedPhoneNumber","findCountryCode","stripNationalPrefixAndCarrierCode","stripNationalPrefixAndCarrierCodeFromCompleteNumber","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","FIRST_GROUP_PATTERN","formatNationalNumberUsingFormat","applyInternationalSeparatorStyle","stripIDDPrefix","checkNumberLengthForType","parseDigits","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","NATIONAL_PREFIX_SEPARATORS_PATTERN","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_FORMATTED_PHONE_NUMBER_PART","VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","AsYouType","optionsOrDefaultCountry","metadata","defaultCountry","defaultCallingCode","hasCountry","isNonGeographicCallingCode","reset","formattedOutput","international","undefined","internationalPrefix","countryCallingCode","digits","nationalNumberDigits","nationalPrefix","carrierCode","setCountry","resetFormat","country","callingCode","selectNumberingPlan","hasSelectedNumberingPlan","initializePhoneNumberFormatsForCountry","matchingFormats","chosenFormat","template","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","text","formattedDigits","extractFormattedDigits","test","getFullNumber","inputDigits","getNonFormattedNationalNumber","extractedNumber","indexOf","slice","length","isInternational","startInternationalNumber","nextDigits","numberWithoutIDD","isCountryCallingCodeAmbiguous","determineTheCountry","previousNationalPrefix","extractNationalPrefix","matchFormats","formatNationalNumberWithNextDigits","formattedNumber","attemptToFormatCompletePhoneNumber","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","reformatNationalNumber","format","createFormattingTemplate","formats","filter","internationalFormat","leadingDigits","leadingDigitsPatternIndex","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","nationalPrefixFormattingRule","matcher","pattern","formattedNationalNumber","formattedNationalNumberWithNationalPrefix","getSeparatorAfterNationalPrefix","replace","options","spacing","prefix","getInternationalPrefix","number","chooseCountryByCountryCallingCode","nationalNumber","index","countryCodes","getCountryCodesForCallingCode","getTemplateForNumberFormatPattern","match","strictPattern","nationalNumberDummyDigits","numberFormat","getFormatFormat","includesNationalPrefix","numberFormatWithNationalPrefix","i","split","digit","search","cutAndStripNonPairedParens","countryCode","shorterNationalNumber","newCarrierCode","phoneNumber","getNonFormattedTemplate","stripNonPairedParens","string","dangling_braces","push","pop","start","cleared_string","cutBeforeIndex","closeNonPairedParens","cut_before","retained_template","opening_braces","countOccurences","closing_braces","symbol","count","character","times","result"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAOA,QAAP,MAAqB,YAArB;AAEA,OAAOC,WAAP,MAAwB,eAAxB;AAEA,SACCC,YADD,EAECC,iBAFD,EAGCC,UAHD,QAIO,aAJP;AAMA,SAASC,eAAT,QAAgC,QAAhC;AAEA,SACCC,yBAAyB,IAAzBA,0BADD,EAECC,2BAFD,EAGCC,eAHD,EAICC,iCAJD,EAKCC,mDALD,EAMCC,+DAND,QAOO,UAPP;AASA,SACCC,mBADD,EAECC,+BAFD,EAGCC,gCAHD,QAIO,WAJP;AAMA,SAASC,cAAT,QAA+B,OAA/B;AAEA,SAASC,wBAAT,QAAyC,kBAAzC;AAEA,OAAOC,WAAP,MAAwB,eAAxB,C,CAEA;AACA;;AACA,IAAMC,WAAW,GAAG,GAApB,C,CACA;;AACA,IAAMC,oCAAoC,GAAG,EAA7C,C,CACA;AACA;;AACA,IAAMC,0BAA0B,GAAGC,MAAM,CAACH,WAAD,EAAcC,oCAAd,CAAzC,C,CAEA;AACA;;AACA,OAAO,IAAMG,iBAAiB,GAAG,GAA1B,C,CAA8B;;AACrC,IAAMC,yBAAyB,GAAG,IAAIC,MAAJ,CAAWF,iBAAX,CAAlC,C,CAEA;AACA;;AACA,IAAMG,kCAAkC,GAAG,MAA3C,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,kCAAkC,GAAG,IAA3C,C,CAEA;AACA;;AACA,IAAMC,8BAA8B,GAAGD,kCAAkC,IAAK;AAAA,SAAM,iBAAN;AAAA,CAA9E,C,CAEA;AACA;AACA;AACA;AACA;;;AACA,IAAME,+BAA+B,GAAGF,kCAAkC,IAAK;AAAA,SAAM,mBAAN;AAAA,CAA/E,C,CAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,uBAAuB,GAAG,IAAIL,MAAJ,CAC/B,MACA,GADA,GACMrB,iBADN,GAC0B,IAD1B,GAEA,UAFA,GAEaA,iBAFb,GAEiC,MAFjC,GAGA,GAJ+B,CAAhC,C,CAOA;AACA;AACA;;AACA,IAAM2B,yBAAyB,GAAG,CAAlC;AAEA,IAAMC,iCAAiC,GACtC,MACC5B,iBADD,GAECD,YAFD,GAGA,IAJD;AAMA,IAAM8B,yCAAyC,GAAG,IAAIR,MAAJ,CAAW,MAAMO,iCAAN,GAA0C,GAArD,EAA0D,GAA1D,CAAlD;AAEA,IAAME,+BAA+B,GAAG,KAAxC;;IAEqBC,S;;;AACpB;AACA;AACA;;AAGA;;;;AAIA,qBAAYC,uBAAZ,EAAqCC,QAArC,EAA+C;AAAA;;AAAA,qCANrC,EAMqC;;AAC9C,SAAKA,QAAL,GAAgB,IAAIpC,QAAJ,CAAaoC,QAAb,CAAhB,CAD8C,CAE9C;;AACA,QAAIC,cAAJ;AACA,QAAIC,kBAAJ,CAJ8C,CAK9C;;AACA,QAAIH,uBAAJ,EAA6B;AAC5B,UAAI,QAAOA,uBAAP,MAAmC,QAAvC,EAAiD;AAChDE,QAAAA,cAAc,GAAGF,uBAAuB,CAACE,cAAzC;AACAC,QAAAA,kBAAkB,GAAGH,uBAAuB,CAACG,kBAA7C;AACA,OAHD,MAGO;AACND,QAAAA,cAAc,GAAGF,uBAAjB;AACA;AACD;;AACD,QAAIE,cAAc,IAAI,KAAKD,QAAL,CAAcG,UAAd,CAAyBF,cAAzB,CAAtB,EAAgE;AAC/D,WAAKA,cAAL,GAAsBA,cAAtB;AACA;;AACD,QAAIC,kBAAJ,EAAwB;AACvB;AACA,UAAIL,+BAAJ,EAAqC;AACpC,YAAI,KAAKG,QAAL,CAAcI,0BAAd,CAAyCF,kBAAzC,CAAJ,EAAkE;AACjE,eAAKD,cAAL,GAAsB,KAAtB;AACA;AACD;;AACD,WAAKC,kBAAL,GAA0BA,kBAA1B;AACA,KAzB6C,CA0B9C;;;AACA,SAAKG,KAAL;AACA;;;;4BAEO;AACP,WAAKC,eAAL,GAAuB,EAAvB;AACA,WAAKC,aAAL,GAAqBC,SAArB;AACA,WAAKC,mBAAL,GAA2BD,SAA3B;AACA,WAAKE,kBAAL,GAA0BF,SAA1B;AACA,WAAKG,MAAL,GAAc,EAAd;AACA,WAAKC,oBAAL,GAA4B,EAA5B;AACA,WAAKC,cAAL,GAAsB,EAAtB;AACA,WAAKC,WAAL,GAAmB,EAAnB;AACA,WAAKC,UAAL,CAAgB,KAAKd,cAArB,EAAqC,KAAKC,kBAA1C;AACA,WAAKc,WAAL;AACA,aAAO,IAAP;AACA;;;+BAEUC,O,EAASC,W,EAAa;AAChC,WAAKD,OAAL,GAAeA,OAAf;AACA,WAAKjB,QAAL,CAAcmB,mBAAd,CAAkCF,OAAlC,EAA2CC,WAA3C;;AACA,UAAI,KAAKlB,QAAL,CAAcoB,wBAAd,EAAJ,EAA8C;AAC7C,aAAKC,sCAAL;AACA,OAFD,MAEO;AACN,aAAKC,eAAL,GAAuB,EAAvB;AACA;AACD;;;kCAEa;AACb,WAAKC,YAAL,GAAoBf,SAApB;AACA,WAAKgB,QAAL,GAAgBhB,SAAhB;AACA,WAAKiB,+BAAL,GAAuCjB,SAAvC;AACA,WAAKkB,uCAAL,GAA+C,CAAC,CAAhD;AACA;AAED;;;;;;;;0BAKMC,I,EAAM;AACX,UAAMC,eAAe,GAAG,KAAKC,sBAAL,CAA4BF,IAA5B,CAAxB,CADW,CAEX;AACA;AACA;;AACA,UAAI/B,yCAAyC,CAACkC,IAA1C,CAA+CF,eAA/C,CAAJ,EAAqE;AACpE,aAAKtB,eAAL,GAAuB,KAAKyB,aAAL,CACtB,KAAKC,WAAL,CAAiBnD,WAAW,CAAC+C,eAAD,CAA5B,KACA,KAAKK,6BAAL,EAFsB,CAAvB;AAIA;;AACD,aAAO,KAAK3B,eAAZ;AACA;AAED;;;;;;;;2CAKuBqB,I,EAAM;AAC5B;AACA,UAAIO,eAAe,GAAG/D,2BAA2B,CAACwD,IAAD,CAA3B,IAAqC,EAA3D,CAF4B,CAG5B;AACA;;AACA,UAAI,CAACO,eAAL,EAAsB;AACrB,YAAIP,IAAI,IAAIA,IAAI,CAACQ,OAAL,CAAa,GAAb,KAAqB,CAAjC,EAAoC;AACnCD,UAAAA,eAAe,GAAG,GAAlB;AACA;AACD,OAT2B,CAU5B;;;AACA,UAAIA,eAAe,CAAC,CAAD,CAAf,KAAuB,GAA3B,EAAgC;AAC/B;AACAA,QAAAA,eAAe,GAAGA,eAAe,CAACE,KAAhB,CAAsB,IAAIC,MAA1B,CAAlB;;AACA,YAAI,KAAK1B,MAAL,IAAe,KAAK2B,eAAL,EAAnB,EAA2C,CAC1C;AACA;AACA,SAHD,MAGO;AACN,eAAKC,wBAAL;AACA;AACD;;AACD,aAAOL,eAAP;AACA;;;+CAE0B;AAC1B;AACA,WAAK3B,aAAL,GAAqB,IAArB,CAF0B,CAG1B;AACA;AACA;;AACA,WAAKQ,UAAL;AACA;AAED;;;;;;;;gCAKYyB,U,EAAY;AACvB;AACA;AACA;AACA;AACA,UAAI,CAAC,KAAK7B,MAAV,EAAkB;AACjB,YAAM8B,gBAAgB,GAAG9D,cAAc,CACtC6D,UADsC,EAEtC,KAAKvC,cAFiC,EAGtC,KAAKC,kBAHiC,EAItC,KAAKF,QAAL,CAAcA,QAJwB,CAAvC;;AAMA,YAAIyC,gBAAgB,IAAIA,gBAAgB,KAAKD,UAA7C,EAAyD;AACxD;AACA;AACA;AACA,eAAK/B,mBAAL,GAA2B+B,UAAU,CAACJ,KAAX,CAAiB,CAAjB,EAAoBI,UAAU,CAACH,MAAX,GAAoBI,gBAAgB,CAACJ,MAAzD,CAA3B;AACAG,UAAAA,UAAU,GAAGC,gBAAb;AACA,eAAKF,wBAAL;AACA;AACD,OApBsB,CAqBvB;;;AACA,WAAK5B,MAAL,IAAe6B,UAAf,CAtBuB,CAuBvB;;AACA,UAAI,KAAKF,eAAL,EAAJ,EAA4B;AAC3B,YAAI,KAAK5B,kBAAT,EAA6B;AAC5B,eAAKE,oBAAL,IAA6B4B,UAA7B,CAD4B,CAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,cAAI,CAAC,KAAKvB,OAAN,IAAiB,KAAKyB,6BAAL,EAArB,EAA2D;AAC1D,iBAAKC,mBAAL;AACA;AACD,SAZD,MAYO;AACN;AACA;AACA,cAAI,CAAC,KAAKhC,MAAV,EAAkB;AACjB;AACA;AACA,WANK,CAON;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,cAAI,CAAC,KAAKzC,yBAAL,EAAL,EAAuC;AACtC;AACA;AACA,WAnBK,CAoBN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAK0C,oBAAL,GAA4B,KAAKD,MAAL,CAAYyB,KAAZ,CAAkB,KAAK1B,kBAAL,CAAwB2B,MAA1C,CAA5B,CA5CM,CA6CN;AACA;AACA;;AACA,eAAKM,mBAAL;AACA;AACD,OA/DD,MA+DO;AACN,aAAK/B,oBAAL,IAA6B4B,UAA7B,CADM,CAEN;AACA;;AACA,YAAI,CAAC,KAAKvB,OAAV,EAAmB;AAClB,eAAK0B,mBAAL;AACA,SANK,CAON;AACA;AACA;;;AACA,YAAMC,sBAAsB,GAAG,KAAK/B,cAApC;AACA,aAAKD,oBAAL,GAA4B,KAAKC,cAAL,GAAsB,KAAKD,oBAAvD,CAXM,CAYN;;AACA,aAAKiC,qBAAL,GAbM,CAcN;;AACA,YAAI,KAAKhC,cAAL,KAAwB+B,sBAA5B,EAAoD;AACnD;AACA;AACA;AACA;AACA;AACA,eAAKvB,sCAAL;AACA,eAAKL,WAAL;AACA;AACD;;AAED,UAAI,KAAKJ,oBAAT,EAA+B;AAC9B;AACA,aAAKkC,YAAL,CAAkB,KAAKlC,oBAAvB;AACA,OApHsB,CAsHvB;;;AACA,aAAO,KAAKmC,kCAAL,CAAwCP,UAAxC,CAAP;AACA;;;uDAEkCA,U,EAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,UAAMQ,eAAe,GAAG,KAAKC,kCAAL,EAAxB,CAN8C,CAQ9C;AACA;AACA;AACA;AACA;;AACA,UAAID,eAAJ,EAAqB;AACpB,eAAOA,eAAP;AACA,OAf6C,CAiB9C;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAME,sBAAsB,GAAG,KAAK3B,YAApC,CAxB8C,CAyB9C;;AACA,UAAM4B,iBAAiB,GAAG,KAAKC,YAAL,EAA1B;;AACA,UAAID,iBAAJ,EAAuB;AACtB,YAAIA,iBAAiB,KAAKD,sBAA1B,EAAkD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAO,KAAKG,8BAAL,CAAoCb,UAApC,CAAP;AACA,SAXD,MAWO;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAO,KAAKc,sBAAL,EAAP;AACA;AACD;AACD;;;mCAEc;AACd;AACA;AACA,2BAAqB,KAAKhC,eAA1B,kHAA2C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAhCiC,MAAgC;;AAC1C;AACA;AACA,YAAI,KAAKhC,YAAL,KAAsBgC,MAA1B,EAAkC;AACjC;AACA;;AACD,YAAI,CAAC,KAAKC,wBAAL,CAA8BD,MAA9B,CAAL,EAA4C;AAC3C;AACA;;AACD,aAAKhC,YAAL,GAAoBgC,MAApB,CAT0C,CAU1C;AACA;;AACA,aAAK7B,uCAAL,GAA+C,CAAC,CAAhD;AACA;AACA;;AACD,UAAI,CAAC,KAAKH,YAAV,EAAwB;AACvB;AACA,aAAKP,WAAL;AACA;;AACD,aAAO,KAAKO,YAAZ;AACA,K,CAED;AACA;;;;6CACyB;AACxB,aAAO,KAAK8B,8BAAL,CACN,KAAKxC,cAAL,GAAsB,KAAKD,oBADrB,CAAP;AAGA;;;6DAEwC;AACxC;AACA,WAAKU,eAAL,GAAuB,KAAKtB,QAAL,CAAcyD,OAAd,GAAwBC,MAAxB,CAA+B,UAACH,MAAD,EAAY;AACjE;AACA;AACA;AACA;AACA;AACA,eAAO9D,uBAAuB,CAACqC,IAAxB,CAA6ByB,MAAM,CAACI,mBAAP,EAA7B,CAAP;AACA,OAPsB,CAAvB;AAQA;;;iCAEYC,a,EAAe;AAAA;;AAC3B;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,UAAIC,yBAAyB,GAAGD,aAAa,CAACvB,MAAd,GAAuB3C,yBAAvD;;AACA,UAAImE,yBAAyB,GAAG,CAAhC,EAAmC;AAClCA,QAAAA,yBAAyB,GAAG,CAA5B;AACA;;AAED,WAAKvC,eAAL,GAAuB,KAAKA,eAAL,CAAqBoC,MAArB,CAA4B,UAACH,MAAD,EAAY;AAC9D;AACA;AACA;AACA,YAAI,CAAC,KAAI,CAACjB,eAAL,EAAD,IAA2B,CAAC,KAAI,CAACzB,cAAjC,IAAmD0C,MAAM,CAACO,uDAAP,EAAvD,EAAyH;AACxH,iBAAO,KAAP;AACA;;AACD,YAAMC,0BAA0B,GAAGR,MAAM,CAACS,qBAAP,GAA+B3B,MAAlE,CAP8D,CAQ9D;AACA;;AACA,YAAI0B,0BAA0B,KAAK,CAAnC,EAAsC;AACrC,iBAAO,IAAP;AACA,SAZ6D,CAa9D;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAIH,aAAa,CAACvB,MAAd,GAAuB3C,yBAA3B,EAAsD;AACrD,iBAAO,IAAP;AACA,SAtB6D,CAuB9D;AACA;AACA;;;AACAmE,QAAAA,yBAAyB,GAAGI,IAAI,CAACC,GAAL,CAASL,yBAAT,EAAoCE,0BAA0B,GAAG,CAAjE,CAA5B;AACA,YAAMI,oBAAoB,GAAGZ,MAAM,CAACS,qBAAP,GAA+BH,yBAA/B,CAA7B,CA3B8D,CA4B9D;AACA;;AACA,eAAO,IAAIzE,MAAJ,aAAgB+E,oBAAhB,QAAyCrC,IAAzC,CAA8C8B,aAA9C,CAAP;AACA,OA/BsB,CAAvB,CAlB2B,CAmD3B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,KAAKrC,YAAL,IAAqB,KAAKD,eAAL,CAAqBa,OAArB,CAA6B,KAAKZ,YAAlC,MAAoD,CAAC,CAA9E,EAAiF;AAChF,aAAKP,WAAL;AACA;AACD;;;oDAE+BuC,M,EAAQ;AACvC,UAAI,KAAKvD,QAAL,CAAcU,kBAAd,OAAuC,GAA3C,EAAgD;AAC/C,eAAO,GAAP;AACA;;AACD,UAAI6C,MAAM,IACTA,MAAM,CAACa,4BAAP,EADG,IAEH/E,kCAAkC,CAACyC,IAAnC,CAAwCyB,MAAM,CAACa,4BAAP,EAAxC,CAFD,EAEiF;AAChF,eAAO,GAAP;AACA;;AACD,aAAO,EAAP;AACA,K,CAED;AACA;AACA;AACA;;;;yDACqC;AACpC,4BAAqB,KAAK9C,eAA1B,yHAA2C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAAhCiC,MAAgC;AAC1C,YAAMc,OAAO,GAAG,IAAIjF,MAAJ,eAAkBmE,MAAM,CAACe,OAAP,EAAlB,QAAhB;;AACA,YAAI,CAACD,OAAO,CAACvC,IAAR,CAAa,KAAKlB,oBAAlB,CAAL,EAA8C;AAC7C;AACA,SAJyC,CAK1C;AACA;AACA;AACA;;;AACA,YAAI2D,uBAAuB,GAAG9F,+BAA+B,CAC5D,KAAKmC,oBADuD,EAE5D2C,MAF4D,EAG5D,KAAKjB,eAAL,EAH4D,EAI5D,KAJ4D,EAIrD;AACP,aAAKtC,QALuD,CAA7D,CAT0C,CAgB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAInB,WAAW,CAAC0F,uBAAD,CAAX,KAAyC,KAAK3D,oBAAlD,EAAwE;AACvE;AACA,SAnCyC,CAoC1C;;;AACA,YAAI,KAAKC,cAAT,EAAyB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,cAAM2D,yCAAyC,GAAG/F,+BAA+B,CAChF,KAAKmC,oBAD2E,EAEhF2C,MAFgF,EAGhF,KAAKjB,eAAL,EAHgF,EAIhF,IAJgF,EAI1E;AACN,eAAKtC,QAL2E,CAAjF;;AAOA,cAAInB,WAAW,CAAC2F,yCAAD,CAAX,KAA2D,KAAK3D,cAAL,GAAsB,KAAKD,oBAA1F,EAAgH;AAC/G2D,YAAAA,uBAAuB,GAAGC,yCAA1B;AACA,WAFD,MAEO;AACND,YAAAA,uBAAuB,GAAG,KAAK1D,cAAL,GACzB,KAAK4D,+BAAL,CAAqClB,MAArC,CADyB,GAEzBgB,uBAFD;AAGA;AACD,SA1DyC,CA4D1C;AACA;AACA;AACA;AACA;AAEA;;;AACA,aAAKvD,WAAL;AACA,aAAKO,YAAL,GAAoBgC,MAApB,CApE0C,CAqE1C;;AACA;;AACA,YAAI,KAAKC,wBAAL,CAA8BD,MAA9B,CAAJ,EAA2C;AAC1C;AACA,eAAKD,sBAAL;AACA,SAHD,MAGO;AACN;AACA;AACA;AACA,eAAK9B,QAAL,GAAgB,KAAKO,aAAL,CAAmBwC,uBAAnB,EAA4CG,OAA5C,CAAoD,SAApD,EAA+DxF,iBAA/D,CAAhB;AACA,eAAKuC,+BAAL,GAAuC8C,uBAAvC;AACA,eAAK7C,uCAAL,GAA+C,KAAKD,+BAAL,CAAqCY,MAArC,GAA8C,CAA7F;AACA;;AACD,eAAOkC,uBAAP;AACA;AACD;;;2CAEsBI,O,EAAS;AAC/B,aAAO,KAAKlE,mBAAL,GACNkE,OAAO,IAAIA,OAAO,CAACC,OAAR,KAAoB,KAA/B,GAAuC,KAAKnE,mBAA5C,GAAkE,KAAKA,mBAAL,GAA2B,GADvF,GAEH,GAFJ;AAGA,K,CAED;;;;kCACc8D,uB,EAAyB;AACtC,UAAI,KAAKjC,eAAL,EAAJ,EAA4B;AAC3B,YAAMuC,MAAM,GAAG,KAAKC,sBAAL,EAAf;;AACA,YAAI,CAAC,KAAKpE,kBAAV,EAA8B;AAC7B,2BAAUmE,MAAV,SAAmB,KAAKlE,MAAxB;AACA;;AACD,YAAI,CAAC4D,uBAAL,EAA8B;AAC7B,2BAAUM,MAAV,SAAmB,KAAKnE,kBAAxB;AACA;;AACD,yBAAUmE,MAAV,SAAmB,KAAKnE,kBAAxB,cAA8C6D,uBAA9C;AACA;;AACD,aAAOA,uBAAP;AACA;;;oDAE+B;AAC/B,aAAO,KAAK1D,cAAL,IACL,KAAKA,cAAL,IAAuB,KAAKD,oBAA5B,IAAoD,KAAK6D,+BAAL,EAD/C,IAEN,KAAK7D,oBAFN;AAGA,K,CAED;AACA;AACA;;;;gDAC4B;AAAA,kCAIvB1C,0BAAyB,CAC5B,MAAM,KAAKyC,MADiB,EAE5B,KAAKV,cAFuB,EAG5B,KAAKC,kBAHuB,EAI5B,KAAKF,QAAL,CAAcA,QAJc,CAJF;AAAA,UAE1BU,kBAF0B,yBAE1BA,kBAF0B;AAAA,UAG1BqE,MAH0B,yBAG1BA,MAH0B;;AAU3B,UAAI,CAACrE,kBAAL,EAAyB;AACxB;AACA;;AACD,WAAKE,oBAAL,GAA4BmE,MAA5B;AACA,WAAKrE,kBAAL,GAA0BA,kBAA1B;AACA,WAAKV,QAAL,CAAcgF,iCAAd,CAAgDtE,kBAAhD;AACA,WAAKW,sCAAL;AACA,WAAKL,WAAL;AACA,aAAO,KAAKhB,QAAL,CAAcoB,wBAAd,EAAP;AACA;;;4CAEuB;AACvB,WAAKP,cAAL,GAAsB,EAAtB;;AACA,UAAI,CAAC,KAAKb,QAAL,CAAcoB,wBAAd,EAAL,EAA+C;AAC9C;AACA,OAJsB,CAKvB;AACA;AACA;;;AAPuB,kCAWnB/C,iCAAiC,CACpC,KAAKuC,oBAD+B,EAEpC,KAAKZ,QAF+B,CAXd;AAAA,UAStBiF,cATsB,yBAStBA,cATsB;AAAA,UAUtBnE,WAVsB,yBAUtBA,WAVsB,EAevB;AACA;AACA;AACA;AACA;;;AACA,UAAImE,cAAJ,EAAoB;AACnB,YAAMC,KAAK,GAAG,KAAKtE,oBAAL,CAA0BuB,OAA1B,CAAkC8C,cAAlC,CAAd;;AACA,YAAIC,KAAK,GAAG,CAAR,IAAaA,KAAK,KAAK,KAAKtE,oBAAL,CAA0ByB,MAA1B,GAAmC4C,cAAc,CAAC5C,MAA7E,EAAqF;AACpF;AACA;AACD;;AACD,UAAIvB,WAAJ,EAAiB;AAChB,aAAKA,WAAL,GAAmBA,WAAnB;AACA;;AACD,WAAKD,cAAL,GAAsB,KAAKD,oBAAL,CAA0BwB,KAA1B,CAAgC,CAAhC,EAAmC,KAAKxB,oBAAL,CAA0ByB,MAA1B,GAAmC4C,cAAc,CAAC5C,MAArF,CAAtB;AACA,WAAKzB,oBAAL,GAA4BqE,cAA5B;AACA,aAAO,KAAKpE,cAAZ;AACA,K,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;oDAEgC;AAC/B,UAAMsE,YAAY,GAAG,KAAKnF,QAAL,CAAcoF,6BAAd,CAA4C,KAAK1E,kBAAjD,CAArB;AACA,aAAOyE,YAAY,IAAIA,YAAY,CAAC9C,MAAb,GAAsB,CAA7C;AACA;;;6CAEwBkB,M,EAAQ;AAChC;AACA;AACA;;AACA;AACA,UAAIjE,kCAAkC,IAAIiE,MAAM,CAACe,OAAP,GAAiBnC,OAAjB,CAAyB,GAAzB,KAAiC,CAA3E,EAA8E;AAC7E;AACA,OAP+B,CAQhC;;;AACA,UAAIX,QAAQ,GAAG,KAAK6D,iCAAL,CAAuC9B,MAAvC,EAA+C,KAAK1C,cAApD,CAAf,CATgC,CAUhC;AACA;;AACA,UAAI,CAACW,QAAL,EAAe;AACd;AACA;;AACD,WAAKA,QAAL,GAAgBA,QAAhB;AACA,WAAKC,+BAAL,GAAuCD,QAAvC,CAhBgC,CAiBhC;AACA;AACA;AACA;AACA;;AACA,UAAI,KAAKc,eAAL,EAAJ,EAA4B;AAC3B,aAAKd,QAAL,GACC,KAAKsD,sBAAL,GAA8BJ,OAA9B,CAAsC,SAAtC,EAAiDxF,iBAAjD,IACAD,MAAM,CAACC,iBAAD,EAAoB,KAAKwB,kBAAL,CAAwB2B,MAA5C,CADN,GAEA,GAFA,GAGAb,QAJD;AAKA;;AACD,aAAO,KAAKA,QAAZ;AACA;AAED;;;;;;;;;;sDAOkC+B,M,EAAQ1C,c,EAAgB;AACzD,UAAIyD,OAAO,GAAGf,MAAM,CAACe,OAAP,EAAd;AAEA;;AACA,UAAIhF,kCAAJ,EAAwC;AACvCgF,QAAAA,OAAO,GAAGA,OAAO,CAChB;AADgB,SAEfI,OAFQ,CAEAnF,8BAA8B,EAF9B,EAEkC,KAFlC,EAGT;AAHS,SAIRmF,OAJQ,CAIAlF,+BAA+B,EAJ/B,EAImC,KAJnC,CAAV;AAKA,OAVwD,CAYzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAImB,MAAM,GAAG3B,0BAA0B,CAACsG,KAA3B,CAAiChB,OAAjC,EAA0C,CAA1C,CAAb,CApByD,CAsBzD;AACA;;AACA,UAAI,KAAK1D,oBAAL,CAA0ByB,MAA1B,GAAmC1B,MAAM,CAAC0B,MAA9C,EAAsD;AACrD;AACA,OA1BwD,CA4BzD;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,UAAMkD,aAAa,GAAG,IAAInG,MAAJ,CAAW,MAAMkF,OAAN,GAAgB,GAA3B,CAAtB;AACA,UAAMkB,yBAAyB,GAAG,KAAK5E,oBAAL,CAA0B8D,OAA1B,CAAkC,KAAlC,EAAyC5F,WAAzC,CAAlC,CA5DyD,CA8DzD;AACA;AACA;;AACA,UAAIyG,aAAa,CAACzD,IAAd,CAAmB0D,yBAAnB,CAAJ,EAAmD;AAClD7E,QAAAA,MAAM,GAAG6E,yBAAT;AACA;;AAED,UAAIC,YAAY,GAAG,KAAKC,eAAL,CAAqBnC,MAArB,CAAnB;AACA,UAAIoC,sBAAJ;;AAEA,UAAI9E,cAAJ,EAAoB;AACnB,YAAI0C,MAAM,CAACa,4BAAP,EAAJ,EAA2C;AAC1C,cAAMwB,8BAA8B,GAAGH,YAAY,CAACf,OAAb,CACtClG,mBADsC,EAEtC+E,MAAM,CAACa,4BAAP,EAFsC,CAAvC;;AAIA,cAAIvF,WAAW,CAAC+G,8BAAD,CAAX,KAAgD/E,cAAc,GAAGhC,WAAW,CAAC4G,YAAD,CAAhF,EAAgG;AAC/FA,YAAAA,YAAY,GAAGG,8BAAf;AACAD,YAAAA,sBAAsB,GAAG,IAAzB;AACA,gBAAIE,CAAC,GAAGhF,cAAc,CAACwB,MAAvB;;AACA,mBAAOwD,CAAC,GAAG,CAAX,EAAc;AACbJ,cAAAA,YAAY,GAAGA,YAAY,CAACf,OAAb,CAAqB,IAArB,EAA2BxF,iBAA3B,CAAf;AACA2G,cAAAA,CAAC;AACD;AACD;AACD;AACD,OAxFwD,CA0FzD;;;AACA,UAAIrE,QAAQ,GAAGb,MAAM,CACpB;AADoB,OAEnB+D,OAFa,CAEL,IAAItF,MAAJ,CAAWkF,OAAX,CAFK,EAEgBmB,YAFhB,EAGd;AAHc,OAIbf,OAJa,CAIL,IAAItF,MAAJ,CAAWN,WAAX,EAAwB,GAAxB,CAJK,EAIyBI,iBAJzB,CAAf;;AAMA,UAAI2B,cAAJ,EAAoB;AACnB,YAAI,CAAC8E,sBAAL,EAA6B;AAC5B;AACAnE,UAAAA,QAAQ,GAAGvC,MAAM,CAACC,iBAAD,EAAoB2B,cAAc,CAACwB,MAAnC,CAAN,GACV,KAAKoC,+BAAL,CAAqClB,MAArC,CADU,GAEV/B,QAFD;AAGA;AACD;;AAED,aAAOA,QAAP;AACA;;;mDAE8Bb,M,EAAQ;AACtC;AACA;AACA;AACA;AACA;AACA,4BAAoBA,MAAM,CAACmF,KAAP,CAAa,EAAb,CAApB,yHAAsC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YAA3BC,KAA2B;;AACrC;AACA;AACA;AACA;AACA,YAAI,KAAKtE,+BAAL,CAAqCW,KAArC,CAA2C,KAAKV,uCAAL,GAA+C,CAA1F,EAA6FsE,MAA7F,CAAoG7G,yBAApG,IAAiI,CAArI,EAAwI;AACvI;AACA,eAAK6B,WAAL;AACA;AACA;;AAED,aAAKU,uCAAL,GAA+C,KAAKD,+BAAL,CAAqCuE,MAArC,CAA4C7G,yBAA5C,CAA/C;AACA,aAAKsC,+BAAL,GAAuC,KAAKA,+BAAL,CAAqCiD,OAArC,CAA6CvF,yBAA7C,EAAwE4G,KAAxE,CAAvC;AACA,OAnBqC,CAqBtC;;;AACA,aAAOE,0BAA0B,CAAC,KAAKxE,+BAAN,EAAuC,KAAKC,uCAAL,GAA+C,CAAtF,CAAjC,CAtBsC,CAwBtC;AACA;AACA;AACA;AACA;;;sCAEiB;AACjB,aAAO,KAAKnB,aAAZ;AACA;;;oCAEegD,M,EAAQ;AACvB,UAAI,KAAKjB,eAAL,EAAJ,EAA4B;AAC3B,eAAO5D,gCAAgC,CAAC6E,MAAM,CAACI,mBAAP,EAAD,CAAvC;AACA;;AACD,aAAOJ,MAAM,CAACA,MAAP,EAAP;AACA,K,CAED;AACA;AACA;;;;0CACsB;AACrB,WAAKtC,OAAL,GAAe7C,eAAe,CAC7B,KAAKkE,eAAL,KAAyB,KAAK5B,kBAA9B,GAAmD,KAAKR,kBAD3B,EAE7B,KAAKU,oBAFwB,EAG7B,KAAKZ,QAHwB,CAA9B;AAKA;AAED;;;;;;;;;gCAMY;AACX,UAAI,KAAKsC,eAAL,EAAJ,EAA4B;AAC3B,YAAI,CAAC,KAAK5B,kBAAV,EAA8B;AAC7B;AACA;AACD,OAJD,MAIO;AACN,YAAI,CAAC,KAAKO,OAAN,IAAiB,CAAC,KAAKf,kBAA3B,EAA+C;AAC9C;AACA;AACD;;AACD,UAAI,CAAC,KAAKU,oBAAV,EAAgC;AAC/B,eAAOJ,SAAP;AACA;;AACD,UAAI0F,WAAW,GAAG,KAAKjF,OAAvB;AACA;;AACA,UAAIpB,+BAAJ,EAAqC;AACpC,YAAI,KAAKoB,OAAL,KAAiB,KAArB,EAA4B;AAC3BiF,UAAAA,WAAW,GAAG1F,SAAd;AACA;AACD;;AACD,UAAMU,WAAW,GAAG,KAAKR,kBAAL,IAA2B,KAAKR,kBAApD;AACA,UAAI+E,cAAc,GAAG,KAAKrE,oBAA1B;AACA,UAAIE,WAAW,GAAG,KAAKA,WAAvB,CAtBW,CAuBX;AACA;AACA;AACA;AACA;;AACA,UAAI,CAAC,KAAKwB,eAAL,EAAD,IAA2B,KAAK1B,oBAAL,KAA8B,KAAKD,MAAlE,EAA0E;AAAA,qCAIrEpC,+DAA+D,CAClE,KAAKoC,MAD6D,EAElEuF,WAFkE,EAGlEhF,WAHkE,EAIlE,KAAKlB,QAAL,CAAcA,QAJoD,CAJM;AAAA,YAExEU,kBAFwE,0BAExEA,kBAFwE;AAAA,YAGxEqE,MAHwE,0BAGxEA,MAHwE;;AAUzE,YAAIrE,kBAAJ,EAAwB;AAAA,uCAInBpC,mDAAmD,CACtDyG,MADsD,EAEtD,KAAK/E,QAFiD,CAJhC;AAAA,cAENmG,qBAFM,0BAEtBlB,cAFsB;AAAA,cAGTmB,cAHS,0BAGtBtF,WAHsB;;AAQvBmE,UAAAA,cAAc,GAAGkB,qBAAjB;AACArF,UAAAA,WAAW,GAAGsF,cAAd;AACA;AACD;;AACD,UAAMC,WAAW,GAAG,IAAIxI,WAAJ,CACnBqI,WAAW,IAAIhF,WADI,EAEnB+D,cAFmB,EAGnB,KAAKjF,QAAL,CAAcA,QAHK,CAApB;;AAKA,UAAIc,WAAJ,EAAiB;AAChBuF,QAAAA,WAAW,CAACvF,WAAZ,GAA0BA,WAA1B;AACA,OAzDU,CA0DX;;;AACA,aAAOuF,WAAP;AACA;AAED;;;;;;;;wCAKoB;AACnB,aAAO,KAAKzF,oBAAZ;AACA;;;8CAEyB;AACzB,aAAO,KAAKmB,aAAL,CAAmB,KAAKE,6BAAL,EAAnB,EACLyC,OADK,CACG,SADH,EACcxF,iBADd,CAAP;AAEA;AAED;;;;;;;kCAIc;AACb,UAAI,CAAC,KAAKsC,QAAV,EAAoB;AACnB,eAAO,KAAK8E,uBAAL,EAAP;AACA;;AACD,UAAIpB,KAAK,GAAG,CAAC,CAAb;AACA,UAAIW,CAAC,GAAG,CAAR;;AACA,aAAOA,CAAC,GAAG,CAAC,KAAKvD,eAAL,KAAyB,KAAKwC,sBAAL,CAA4B;AAAEF,QAAAA,OAAO,EAAE;AAAX,OAA5B,EAAgDvC,MAAzE,GAAkF,CAAnF,IAAwF,KAAK1B,MAAL,CAAY0B,MAA/G,EAAuH;AACtH6C,QAAAA,KAAK,GAAG,KAAK1D,QAAL,CAAcW,OAAd,CAAsBjD,iBAAtB,EAAyCgG,KAAK,GAAG,CAAjD,CAAR;AACAW,QAAAA,CAAC;AACD;;AACD,aAAOI,0BAA0B,CAAC,KAAKzE,QAAN,EAAgB0D,KAAK,GAAG,CAAxB,CAAjC;AACA;;;;;;SAt5BmBpF,S;AAy5BrB,OAAO,SAASyG,oBAAT,CAA8BC,MAA9B,EAAsC;AAC5C,MAAMC,eAAe,GAAE,EAAvB;AACA,MAAIZ,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGW,MAAM,CAACnE,MAAlB,EAA0B;AACzB,QAAImE,MAAM,CAACX,CAAD,CAAN,KAAc,GAAlB,EAAuB;AACtBY,MAAAA,eAAe,CAACC,IAAhB,CAAqBb,CAArB;AACA,KAFD,MAGK,IAAIW,MAAM,CAACX,CAAD,CAAN,KAAc,GAAlB,EAAuB;AAC3BY,MAAAA,eAAe,CAACE,GAAhB;AACA;;AACDd,IAAAA,CAAC;AACD;;AACD,MAAIe,KAAK,GAAG,CAAZ;AACA,MAAIC,cAAc,GAAG,EAArB;AACAJ,EAAAA,eAAe,CAACC,IAAhB,CAAqBF,MAAM,CAACnE,MAA5B;;AACA,uCAAoBoE,eAApB,wCAAqC;AAAhC,QAAMvB,KAAK,wBAAX;AACJ2B,IAAAA,cAAc,IAAIL,MAAM,CAACpE,KAAP,CAAawE,KAAb,EAAoB1B,KAApB,CAAlB;AACA0B,IAAAA,KAAK,GAAG1B,KAAK,GAAG,CAAhB;AACA;;AACD,SAAO2B,cAAP;AACA;AAED,OAAO,SAASZ,0BAAT,CAAoCO,MAApC,EAA4CM,cAA5C,EAA4D;AAClE,MAAIN,MAAM,CAACM,cAAD,CAAN,KAA2B,GAA/B,EAAoC;AACnCA,IAAAA,cAAc;AACd;;AACD,SAAOP,oBAAoB,CAACC,MAAM,CAACpE,KAAP,CAAa,CAAb,EAAgB0E,cAAhB,CAAD,CAA3B;AACA;AAED,OAAO,SAASC,oBAAT,CAA8BvF,QAA9B,EAAwCwF,UAAxC,EAAoD;AAC1D,MAAMC,iBAAiB,GAAGzF,QAAQ,CAACY,KAAT,CAAe,CAAf,EAAkB4E,UAAlB,CAA1B;AACA,MAAME,cAAc,GAAGC,eAAe,CAAC,GAAD,EAAMF,iBAAN,CAAtC;AACA,MAAMG,cAAc,GAAGD,eAAe,CAAC,GAAD,EAAMF,iBAAN,CAAtC;AACA,MAAIR,eAAe,GAAGS,cAAc,GAAGE,cAAvC;;AACA,SAAOX,eAAe,GAAG,CAAlB,IAAuBO,UAAU,GAAGxF,QAAQ,CAACa,MAApD,EAA4D;AAC3D,QAAIb,QAAQ,CAACwF,UAAD,CAAR,KAAyB,GAA7B,EAAkC;AACjCP,MAAAA,eAAe;AACf;;AACDO,IAAAA,UAAU;AACV;;AACD,SAAOxF,QAAQ,CAACY,KAAT,CAAe,CAAf,EAAkB4E,UAAlB,CAAP;AACA,C,CAED;AACA;;AACA,OAAO,SAASG,eAAT,CAAyBE,MAAzB,EAAiCb,MAAjC,EAAyC;AAC/C,MAAIc,KAAK,GAAG,CAAZ,CAD+C,CAE/C;AACA;AACA;AACA;AACA;;AACA,wBAAwBd,MAAM,CAACV,KAAP,CAAa,EAAb,CAAxB,yHAA0C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAA/ByB,SAA+B;;AACzC,QAAIA,SAAS,KAAKF,MAAlB,EAA0B;AACzBC,MAAAA,KAAK;AACL;AACD;;AACD,SAAOA,KAAP;AACA,C,CAED;AACA;;AACA,OAAO,SAASrI,MAAT,CAAgBuH,MAAhB,EAAwBgB,KAAxB,EAA+B;AACrC,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACd,WAAO,EAAP;AACA;;AACD,MAAIC,MAAM,GAAG,EAAb;;AACA,SAAOD,KAAK,GAAG,CAAf,EAAkB;AACjB,QAAIA,KAAK,GAAG,CAAZ,EAAe;AACdC,MAAAA,MAAM,IAAIjB,MAAV;AACA;;AACDgB,IAAAA,KAAK,KAAK,CAAV;AACAhB,IAAAA,MAAM,IAAIA,MAAV;AACA;;AACD,SAAOiB,MAAM,GAAGjB,MAAhB;AACA","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n//\r\n// Simplified: does not differentiate between \"local-only\" numbers\r\n// and \"internationally dialable\" numbers.\r\n// For example, doesn't include changes like this:\r\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\n\r\nimport {\r\n\textractCountryCallingCode,\r\n\textractFormattedPhoneNumber,\r\n\tfindCountryCode,\r\n\tstripNationalPrefixAndCarrierCode,\r\n\tstripNationalPrefixAndCarrierCodeFromCompleteNumber,\r\n\textractCountryCallingCodeFromInternationalNumberWithoutPlusSign\r\n} from './parse_'\r\n\r\nimport {\r\n\tFIRST_GROUP_PATTERN,\r\n\tformatNationalNumberUsingFormat,\r\n\tapplyInternationalSeparatorStyle\r\n} from './format_'\r\n\r\nimport { stripIDDPrefix } from './IDD'\r\n\r\nimport { checkNumberLengthForType } from './getNumberType_'\r\n\r\nimport parseDigits from './parseDigits'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART =\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_PART + '$', 'i')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\nexport default class AsYouType {\r\n\t// Not setting `options` to a constructor argument\r\n\t// not to break backwards compatibility\r\n\t// for older versions of the library.\r\n\toptions = {}\r\n\r\n\t/**\r\n\t * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(optionsOrDefaultCountry, metadata) {\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\t\t// Set `defaultCountry` and `defaultCallingCode` options.\r\n\t\tlet defaultCountry\r\n\t\tlet defaultCallingCode\r\n\t\t// Turns out `null` also has type \"object\". Weird.\r\n\t\tif (optionsOrDefaultCountry) {\r\n\t\t\tif (typeof optionsOrDefaultCountry === 'object') {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry.defaultCountry\r\n\t\t\t\tdefaultCallingCode = optionsOrDefaultCountry.defaultCallingCode\r\n\t\t\t} else {\r\n\t\t\t\tdefaultCountry = optionsOrDefaultCountry\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tthis.defaultCountry = defaultCountry\r\n\t\t}\r\n\t\tif (defaultCallingCode) {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tthis.defaultCountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.defaultCallingCode = defaultCallingCode\r\n\t\t}\r\n\t\t// Reset.\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.formattedOutput = ''\r\n\t\tthis.international = undefined\r\n\t\tthis.internationalPrefix = undefined\r\n\t\tthis.countryCallingCode = undefined\r\n\t\tthis.digits = ''\r\n\t\tthis.nationalNumberDigits = ''\r\n\t\tthis.nationalPrefix = ''\r\n\t\tthis.carrierCode = ''\r\n\t\tthis.setCountry(this.defaultCountry, this.defaultCallingCode)\r\n\t\tthis.resetFormat()\r\n\t\treturn this\r\n\t}\r\n\r\n\tsetCountry(country, callingCode) {\r\n\t\tthis.country = country\r\n\t\tthis.metadata.selectNumberingPlan(country, callingCode)\r\n\t\tif (this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t} else {\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number characters.\r\n\t * @param  {string} text\r\n\t * @return {string} Formatted phone number characters that have been input so far.\r\n\t */\r\n\tinput(text) {\r\n\t\tconst formattedDigits = this.extractFormattedDigits(text)\r\n\t\t// If the extracted phone number part\r\n\t\t// can possibly be a part of some valid phone number\r\n\t\t// then parse phone number characters from a formatted phone number.\r\n\t\tif (VALID_FORMATTED_PHONE_NUMBER_PART_PATTERN.test(formattedDigits)) {\r\n\t\t\tthis.formattedOutput = this.getFullNumber(\r\n\t\t\t\tthis.inputDigits(parseDigits(formattedDigits)) ||\r\n\t\t\t\tthis.getNonFormattedNationalNumber()\r\n\t\t\t)\r\n\t\t}\r\n\t\treturn this.formattedOutput\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts formatted phone number digits from text (if there're any).\r\n\t * @param  {string} text\r\n\t * @return {string}\r\n\t */\r\n\textractFormattedDigits(text) {\r\n\t\t// Extract a formatted phone number part from text.\r\n\t\tlet extractedNumber = extractFormattedPhoneNumber(text) || ''\r\n\t\t// Special case for a lone '+' sign\r\n\t\t// because it's not extracted in such cases.\r\n\t\tif (!extractedNumber) {\r\n\t\t\tif (text && text.indexOf('+') >= 0) {\r\n\t\t\t\textractedNumber = '+'\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Trim a `+`.\r\n\t\tif (extractedNumber[0] === '+') {\r\n\t\t\t// Trim the `+`.\r\n\t\t\textractedNumber = extractedNumber.slice('+'.length)\r\n\t\t\tif (this.digits || this.isInternational()) {\r\n\t\t\t\t// If an out of position `+` is detected\r\n\t\t\t\t// (or a second `+`) then just ignore it.\r\n\t\t\t} else {\r\n\t\t\t\tthis.startInternationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn extractedNumber\r\n\t}\r\n\r\n\tstartInternationalNumber() {\r\n\t\t// Prepend the `+` to parsed input.\r\n\t\tthis.international = true\r\n\t\t// If a default country was set then reset it\r\n\t\t// because an explicitly international phone\r\n\t\t// number is being entered.\r\n\t\tthis.setCountry()\r\n\t}\r\n\r\n\t/**\r\n\t * Inputs \"next\" phone number digits.\r\n\t * @param  {string} digits\r\n\t * @return {string} [formattedNumber] Formatted national phone number (if it can be formatted at this stage). Returning `undefined` means \"don't format the national phone number at this stage\".\r\n\t */\r\n\tinputDigits(nextDigits) {\r\n\t\t// Some users input their phone number in \"out-of-country\"\r\n\t\t// dialing format instead of using the leading `+`.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/185\r\n\t\t// Detect such numbers.\r\n\t\tif (!this.digits) {\r\n\t\t\tconst numberWithoutIDD = stripIDDPrefix(\r\n\t\t\t\tnextDigits,\r\n\t\t\t\tthis.defaultCountry,\r\n\t\t\t\tthis.defaultCallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (numberWithoutIDD && numberWithoutIDD !== nextDigits) {\r\n\t\t\t\t// If an IDD prefix was stripped then\r\n\t\t\t\t// convert the number to international one\r\n\t\t\t\t// for subsequent parsing.\r\n\t\t\t\tthis.internationalPrefix = nextDigits.slice(0, nextDigits.length - numberWithoutIDD.length)\r\n\t\t\t\tnextDigits = numberWithoutIDD\r\n\t\t\t\tthis.startInternationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Append phone number digits.\r\n\t\tthis.digits += nextDigits\r\n\t\t// Try to format the parsed input\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (this.countryCallingCode) {\r\n\t\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t\t// `this.country` could be `undefined`, for example, when there is\r\n\t\t\t\t// ambiguity in a form of several different countries,\r\n\t\t\t\t// each corresponding to the same country phone code\r\n\t\t\t\t// (e.g. NANPA: USA, Canada, etc), and there's not enough digits\r\n\t\t\t\t// to reliably determine the country the phone number belongs to.\r\n\t\t\t\t// Therefore, in cases of such ambiguity, each time something is input,\r\n\t\t\t\t// try to determine the country (if it hasn't been determined yet).\r\n\t\t\t\tif (!this.country || this.isCountryCallingCodeAmbiguous()) {\r\n\t\t\t\t\tthis.determineTheCountry()\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// Extract country calling code from the digits entered so far.\r\n\t\t\t\t// There must be some digits in order to extract anything from them.\r\n\t\t\t\tif (!this.digits) {\r\n\t\t\t\t\t// Don't format the phone number.\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then they can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\t\t\t\t//\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then don't format the phone number.\r\n\t\t\t\t//\r\n\t\t\t\tif (!this.extractCountryCallingCode()) {\r\n\t\t\t\t\t// Don't format the phone number.\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\t// Possibly extract a national prefix.\r\n\t\t\t\t// Some people incorrectly input national prefix\r\n\t\t\t\t// in an international phone number.\r\n\t\t\t\t// For example, some people write British phone numbers as `+44(0)...`.\r\n\t\t\t\t// Also, mobile phone numbers in Mexico are supposed to be dialled\r\n\t\t\t\t// internationally using a `15` national prefix.\r\n\t\t\t\t//\r\n\t\t\t\t// https://www.mexperience.com/dialing-cell-phones-in-mexico/\r\n\t\t\t\t//\r\n\t\t\t\t// \"Dialing a Mexican cell phone from abroad\r\n\t\t\t\t// When you are calling a cell phone number in Mexico from outside Mexico,\r\n\t\t\t\t// it’s necessary to dial an additional “1” after Mexico’s country code\r\n\t\t\t\t// (which is “52”) and before the area code.\r\n\t\t\t\t// You also ignore the 045, and simply dial the area code and the\r\n\t\t\t\t// cell phone’s number.\r\n\t\t\t\t//\r\n\t\t\t\t// If you don’t add the “1”, you’ll receive a recorded announcement\r\n\t\t\t\t// asking you to redial using it.\r\n\t\t\t\t//\r\n\t\t\t\t// For example, if you are calling from the USA to a cell phone\r\n\t\t\t\t// in Mexico City, you would dial +52 – 1 – 55 – 1234 5678.\r\n\t\t\t\t// (Note that this is different to calling a land line in Mexico City\r\n\t\t\t\t// from abroad, where the number dialed would be +52 – 55 – 1234 5678)\".\r\n\t\t\t\t//\r\n\t\t\t\tthis.nationalNumberDigits = this.digits.slice(this.countryCallingCode.length)\r\n\t\t\t\t// this.extractNationalPrefix()\r\n\t\t\t\t//\r\n\t\t\t\t// Determine the country from country calling code and national number.\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.nationalNumberDigits += nextDigits\r\n\t\t\t// If `defaultCallingCode` is set,\r\n\t\t\t// see if the `country` could be derived.\r\n\t\t\tif (!this.country) {\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\t\t\tconst previousNationalPrefix = this.nationalPrefix\r\n\t\t\tthis.nationalNumberDigits = this.nationalPrefix + this.nationalNumberDigits\r\n\t\t\t// Re-extract national prefix.\r\n\t\t\tthis.extractNationalPrefix()\r\n\t\t\t// If another national prefix has been extracted.\r\n\t\t\tif (this.nationalPrefix !== previousNationalPrefix) {\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.nationalNumberDigits) {\r\n\t\t\t// Match the available formats by the currently available leading digits.\r\n\t\t\tthis.matchFormats(this.nationalNumberDigits)\r\n\t\t}\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits)\r\n\t}\r\n\r\n\tformatNationalNumberWithNextDigits(nextDigits) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNextNationalNumberDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`.\r\n\t\tconst formattedNumber = this.attemptToFormatCompletePhoneNumber()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone number is invalid,\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formattedNumber) {\r\n\t\t\treturn formattedNumber\r\n\t\t}\r\n\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attemptToFormatCompletePhoneNumber`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat()\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If could format the next (current) digit\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the formatted number so far.\r\n\t\t\t\t//\r\n\t\t\t\t// If no new phone number format could be chosen,\r\n\t\t\t\t// and couldn't format the supplied national number\r\n\t\t\t\t// using the previously chosen phone number pattern,\r\n\t\t\t\t// then return `undefined`.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then format the national phone number (so far)\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\t//\r\n\t\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t\t// the supplied national number\r\n\t\t\t\t// using the selected phone number pattern.\r\n\t\t\t\t//\r\n\t\t\t\treturn this.reformatNationalNumber()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tchooseFormat() {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif (!this.createFormattingTemplate(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national phone number entered.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\t// Formats each digit of the national phone number (so far)\r\n\t// using the selected format.\r\n\treformatNationalNumber() {\r\n\t\treturn this.formatNextNationalNumberDigits(\r\n\t\t\tthis.nationalPrefix + this.nationalNumberDigits\r\n\t\t)\r\n\t}\r\n\r\n\tinitializePhoneNumberFormatsForCountry() {\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.matchingFormats = this.metadata.formats().filter((format) => {\r\n\t\t\t// Compared to `libphonenumber`'s code, the two \"Discard a few formats\r\n\t\t\t// that we know are not relevant based on the presence of the national prefix\"\r\n\t\t\t// checks have changed: the first one has been moved to `.matchFormats()`,\r\n\t\t\t// and the second one doesn't apply to this library because it doesn't deal with\r\n\t\t\t// \"incomplete\" phone numbers (for example, phone numbers, entered without \"area code\").\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat())\r\n\t\t})\r\n\t}\r\n\r\n\tmatchFormats(leadingDigits) {\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter((format) => {\r\n\t\t\t// If national prefix is mandatory for this phone number format\r\n\t\t\t// and the user didn't input the national prefix\r\n\t\t\t// then this phone number format isn't suitable.\r\n\t\t\tif (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\t\t\t// If this format is not restricted to a certain\r\n\t\t\t// leading digits pattern then it fits.\r\n\t\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// Start excluding any non-matching formats only when the\r\n\t\t\t// national number entered so far is at least 3 digits long,\r\n\t\t\t// otherwise format matching would give false negatives.\r\n\t\t\t// For example, when the digits entered so far are `2`\r\n\t\t\t// and the leading digits pattern is `21` –\r\n\t\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\r\n\t\t\t// then format matching starts narrowing down the list of possible formats\r\n\t\t\t// (only previously matched formats are considered for next digits).\r\n\t\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\tif (this.metadata.countryCallingCode() === '1') {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\treturn ''\r\n\t}\r\n\r\n\t// This is in accordance to how Google's `libphonenumber` does it.\r\n\t// \"Check to see if there is an exact pattern match for these digits.\r\n\t// If so, we should use this instead of any other formatting template\r\n\t// whose `leadingDigitsPattern` also matches the input.\"\r\n\tattemptToFormatCompletePhoneNumber() {\r\n\t\tfor (const format of this.matchingFormats) {\r\n\t\t\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\t\t\tif (!matcher.test(this.nationalNumberDigits)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Here, national number is formatted without \"national prefix\r\n\t\t\t// formatting rule\", because otherwise there'd be a bug\r\n\t\t\t// when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\tlet formattedNationalNumber = formatNationalNumberUsingFormat(\r\n\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.isInternational(),\r\n\t\t\t\tfalse, // Don't prepend national prefix (it will be prepended manually).\r\n\t\t\t\tthis.metadata\r\n\t\t\t)\r\n\t\t\t// Check if this `format` preserves all digits.\r\n\t\t\t// This is how it's done in Google's `libphonenumber`.\r\n\t\t\t// Also, it fixes the bug when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t//\r\n\t\t\t// \"Check that we didn't remove nor add any extra digits when we matched\r\n\t\t\t// this formatting pattern. This usually happens after we entered the last\r\n\t\t\t// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when\r\n\t\t\t// formatted but AYTF should retain all the number entered and not change\r\n\t\t\t// in order to match a format (of same leading digits and length) display\r\n\t\t\t// in that way.\"\r\n\t\t\t// \"If it's the same (i.e entered number and format is same), then it's\r\n\t\t\t// safe to return this in formatted number as nothing is lost / added.\"\r\n\t\t\t// Otherwise, don't use this format.\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5\r\n\t\t\t// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b\r\n\t\t\t//\r\n\t\t\tif (parseDigits(formattedNationalNumber) !== this.nationalNumberDigits) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\t// Prepend national prefix (if any).\r\n\t\t\tif (this.nationalPrefix) {\r\n\t\t\t\t// Here, national number is formatted with \"national prefix\r\n\t\t\t\t// formatting rule\". The reason is that \"national prefix\r\n\t\t\t\t// formatting rule\" often adds parentheses, and while Google's\r\n\t\t\t\t// `libphonenumber` dismisses those preferring simply prepending\r\n\t\t\t\t// national prefix followed by a \" \" character, this library\r\n\t\t\t\t// looks if the national prefix could be formatted better.\r\n\t\t\t\tconst formattedNationalNumberWithNationalPrefix = formatNationalNumberUsingFormat(\r\n\t\t\t\t\tthis.nationalNumberDigits,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\tthis.isInternational(),\r\n\t\t\t\t\ttrue, // Prepend national prefix.\r\n\t\t\t\t\tthis.metadata\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(formattedNationalNumberWithNationalPrefix) === this.nationalPrefix + this.nationalNumberDigits) {\r\n\t\t\t\t\tformattedNationalNumber = formattedNationalNumberWithNationalPrefix\r\n\t\t\t\t} else {\r\n\t\t\t\t\tformattedNationalNumber = this.nationalPrefix +\r\n\t\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\t\tformattedNationalNumber\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// formats national number (probably) without national prefix.\r\n\t\t\t// Formatting a national number with national prefix could result in\r\n\t\t\t// bugs when \"area code\" is \"duplicated\" during input:\r\n\t\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/318\r\n\t\t\t// The \"are all digits preserved\" check fixes that type of bug.\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.resetFormat()\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\t// Set `this.template` and `this.populatedNationalNumberTemplate`.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.createFormattingTemplate(format)) {\r\n\t\t\t\t// Populate `this.populatedNationalNumberTemplate` with phone number digits.\r\n\t\t\t\tthis.reformatNationalNumber()\r\n\t\t\t} else {\r\n\t\t\t\t// If the formatting template couldn't be created for a format,\r\n\t\t\t\t// create it manually from the formatted phone number.\r\n\t\t\t\t// This case doesn't ever happen with the current metadata.\r\n\t\t\t\tthis.template = this.getFullNumber(formattedNationalNumber).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.populatedNationalNumberTemplate = formattedNationalNumber\r\n\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.length - 1\r\n\t\t\t}\r\n\t\t\treturn formattedNationalNumber\r\n\t\t}\r\n\t}\r\n\r\n\tgetInternationalPrefix(options) {\r\n\t\treturn this.internationalPrefix ? (\r\n\t\t\toptions && options.spacing === false ? this.internationalPrefix : this.internationalPrefix + ' '\r\n\t\t) : '+'\r\n\t}\r\n\r\n\t// Prepends `+CountryCode ` in case of an international phone number\r\n\tgetFullNumber(formattedNationalNumber) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tconst prefix = this.getInternationalPrefix()\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn `${prefix}${this.digits}`\r\n\t\t\t}\r\n\t\t\tif (!formattedNationalNumber) {\r\n\t\t\t\treturn `${prefix}${this.countryCallingCode}`\r\n\t\t\t}\r\n\t\t\treturn `${prefix}${this.countryCallingCode} ${formattedNationalNumber}`\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\tgetNonFormattedNationalNumber() {\r\n\t\treturn this.nationalPrefix +\r\n\t\t\t(this.nationalPrefix && this.nationalNumberDigits && this.getSeparatorAfterNationalPrefix()) +\r\n\t\t\tthis.nationalNumberDigits\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textractCountryCallingCode() {\r\n\t\tconst {\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnumber\r\n\t\t} = extractCountryCallingCode(\r\n\t\t\t'+' + this.digits,\r\n\t\t\tthis.defaultCountry,\r\n\t\t\tthis.defaultCallingCode,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (!countryCallingCode) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.nationalNumberDigits = number\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\t\tthis.metadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t\tthis.initializePhoneNumberFormatsForCountry()\r\n\t\tthis.resetFormat()\r\n\t\treturn this.metadata.hasSelectedNumberingPlan()\r\n\t}\r\n\r\n\textractNationalPrefix() {\r\n\t\tthis.nationalPrefix = ''\r\n\t\tif (!this.metadata.hasSelectedNumberingPlan()) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Only strip national prefixes for non-international phone numbers\r\n\t\t// because national prefixes can't be present in international phone numbers.\r\n\t\t// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\r\n\t\tconst {\r\n\t\t\tnationalNumber,\r\n\t\t\tcarrierCode\r\n\t\t} = stripNationalPrefixAndCarrierCode(\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t\t// Sometimes `stripNationalPrefixAndCarrierCode()` won't actually\r\n\t\t// strip national prefix and will instead prepend some digits to the `number`:\r\n\t\t// for example, when number `2345678` is passed with `VI` country selected,\r\n\t\t// it will return `{ number: \"3402345678\" }`, because `340` area code is prepended.\r\n\t\t// So check if the `nationalNumber` is actually at the end of `this.nationalNumberDigits`.\r\n\t\tif (nationalNumber) {\r\n\t\t\tconst index = this.nationalNumberDigits.indexOf(nationalNumber)\r\n\t\t\tif (index < 0 || index !== this.nationalNumberDigits.length - nationalNumber.length) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tthis.carrierCode = carrierCode\r\n\t\t}\r\n\t\tthis.nationalPrefix = this.nationalNumberDigits.slice(0, this.nationalNumberDigits.length - nationalNumber.length)\r\n\t\tthis.nationalNumberDigits = nationalNumber\r\n\t\treturn this.nationalPrefix\r\n\t}\r\n\r\n\t// isPossibleNumber(number) {\r\n\t// \tswitch (checkNumberLengthForType(number, undefined, this.metadata)) {\r\n\t// \t\tcase 'IS_POSSIBLE':\r\n\t// \t\t\treturn true\r\n\t// \t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t// \t\t// \treturn !this.isInternational()\r\n\t// \t\tdefault:\r\n\t// \t\t\treturn false\r\n\t// \t}\r\n\t// }\r\n\r\n\tisCountryCallingCodeAmbiguous() {\r\n\t\tconst countryCodes = this.metadata.getCountryCodesForCallingCode(this.countryCallingCode)\r\n\t\treturn countryCodes && countryCodes.length > 1\r\n\t}\r\n\r\n\tcreateFormattingTemplate(format) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tlet template = this.getTemplateForNumberFormatPattern(format, this.nationalPrefix)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tthis.template = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefix().replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t}\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForNumberFormatPattern(format, nationalPrefix) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.nationalNumberDigits.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalNumberDigits : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalNumberDigits`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = this.nationalNumberDigits.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalNumberDigits` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format)\r\n\t\tlet includesNationalPrefix\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t\t)\r\n\t\t\t\tif (parseDigits(numberFormatWithNationalPrefix) === nationalPrefix + parseDigits(numberFormat)) {\r\n\t\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\t\tincludesNationalPrefix = true\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\tif (nationalPrefix) {\r\n\t\t\tif (!includesNationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\t// Using `.split('')` to iterate through a string here\r\n\t\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t\t// `.split('')` is generally not safe for Unicode,\r\n\t\t// but in this particular case for `digits` it is safe.\r\n\t\t// for (const digit of digits)\r\n\t\tfor (const digit of digits.split('')) {\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\t\t\t// If more digits are entered than the current format could handle.\r\n\t\t\tif (this.populatedNationalNumberTemplate.slice(this.populatedNationalNumberTemplatePosition + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) {\r\n\t\t\t\t// Reset the format.\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.populatedNationalNumberTemplatePosition = this.populatedNationalNumberTemplate.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.populatedNationalNumberTemplate = this.populatedNationalNumberTemplate.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tisInternational() {\r\n\t\treturn this.international\r\n\t}\r\n\r\n\tgetFormatFormat(format) {\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn applyInternationalSeparatorStyle(format.internationalFormat())\r\n\t\t}\r\n\t\treturn format.format()\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.country = findCountryCode(\r\n\t\t\tthis.isInternational() ? this.countryCallingCode : this.defaultCallingCode,\r\n\t\t\tthis.nationalNumberDigits,\r\n\t\t\tthis.metadata\r\n\t\t)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber() {\r\n\t\tif (this.isInternational()) {\r\n\t\t\tif (!this.countryCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!this.country && !this.defaultCallingCode) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.nationalNumberDigits) {\r\n\t\t\treturn undefined\r\n\t\t}\r\n\t\tlet countryCode = this.country\r\n\t\t/* istanbul ignore if */\r\n\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\tif (this.country === '001') {\r\n\t\t\t\tcountryCode = undefined\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst callingCode = this.countryCallingCode || this.defaultCallingCode\r\n\t\tlet nationalNumber = this.nationalNumberDigits\r\n\t\tlet carrierCode = this.carrierCode\r\n\t\t// When an international number without a leading `+` has been autocorrected,\r\n\t\t// extract country calling code, because normally it's only extracted\r\n\t\t// for international numbers with a leading `+`.\r\n\t\t// Could also just use `parsePhoneNumberFromString()` here\r\n\t\t// instead of hacking around this single case.\r\n\t\tif (!this.isInternational() && this.nationalNumberDigits === this.digits) {\r\n\t\t\tconst {\r\n\t\t\t\tcountryCallingCode,\r\n\t\t\t\tnumber\r\n\t\t\t} = extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(\r\n\t\t\t\tthis.digits,\r\n\t\t\t\tcountryCode,\r\n\t\t\t\tcallingCode,\r\n\t\t\t\tthis.metadata.metadata\r\n\t\t\t)\r\n\t\t\tif (countryCallingCode) {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tnationalNumber: shorterNationalNumber,\r\n\t\t\t\t\tcarrierCode: newCarrierCode\r\n\t\t\t\t} = stripNationalPrefixAndCarrierCodeFromCompleteNumber(\r\n\t\t\t\t\tnumber,\r\n\t\t\t\t\tthis.metadata\r\n\t\t\t\t)\r\n\t\t\t\tnationalNumber = shorterNationalNumber\r\n\t\t\t\tcarrierCode = newCarrierCode\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCode || callingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tthis.metadata.metadata\r\n\t\t)\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t/**\r\n\t * @deprecated\r\n\t * This method is used in `react-phone-number-input/source/input-control.js`\r\n\t * in versions before `3.0.16`.\r\n\t */\r\n\tgetNationalNumber() {\r\n\t\treturn this.nationalNumberDigits\r\n\t}\r\n\r\n\tgetNonFormattedTemplate() {\r\n\t\treturn this.getFullNumber(this.getNonFormattedNationalNumber())\r\n\t\t\t.replace(/[\\+\\d]/g, DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns formatted phone number template.\r\n\t * @return {string} [template]\r\n\t */\r\n\tgetTemplate() {\r\n\t\tif (!this.template) {\r\n\t\t\treturn this.getNonFormattedTemplate()\r\n\t\t}\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\twhile (i < (this.isInternational() ? this.getInternationalPrefix({ spacing: false }).length : 0) + this.digits.length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n}\r\n\r\nexport function stripNonPairedParens(string) {\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length) {\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces) {\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\treturn cleared_string\r\n}\r\n\r\nexport function cutAndStripNonPairedParens(string, cutBeforeIndex) {\r\n\tif (string[cutBeforeIndex] === ')') {\r\n\t\tcutBeforeIndex++\r\n\t}\r\n\treturn stripNonPairedParens(string.slice(0, cutBeforeIndex))\r\n}\r\n\r\nexport function closeNonPairedParens(template, cut_before) {\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\tconst opening_braces = countOccurences('(', retained_template)\r\n\tconst closing_braces = countOccurences(')', retained_template)\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length) {\r\n\t\tif (template[cut_before] === ')') {\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function countOccurences(symbol, string) {\r\n\tlet count = 0\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split('')) {\r\n\t\tif (character === symbol) {\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times) {\r\n\tif (times < 1) {\r\n\t\treturn ''\r\n\t}\r\n\tlet result = ''\r\n\twhile (times > 1) {\r\n\t\tif (times & 1) {\r\n\t\t\tresult += string\r\n\t\t}\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\treturn result + string\r\n}"],"file":"AsYouType.js"}